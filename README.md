__Note__: весь код работает на ruby 1.9 (не ставил цели запустить на 1.8)

## Level 1

### A1

 1. __nokogiri + mechanize__ - Удобный парсинг сайтов
 2. __wirble__ - autocomplete и подсветка в консоли
 3. __active_support__ - много полезных расширений
 4. __rspec2__ - тесты
 
### A2

Одекватность людей в команде :). Покрытие тестами. Не очень хорошо, когда люди
комитят не рабочий код в основную ветку. Комментарии к коду должны быть на
английском языке, если заказчиком не оговоренно иное. 
Так же удобно называть файлы именами классов (для удобной навигации по 
коду)

### A3

lambda и proc-и часто использую, но ruby более OOP way, чем функциональный.

### A4

Использую Rails (ActiveSupport, ActiveRecord) даже не в web проектах. С 
ActiveRecord удобно поддерживать базу в актуальном состоянии (migrations).
ActiveSupport дает очень много полезных функций.

### A5

Для дебага мне всегда хватает тестов и логов. Для мониторинга нагрузи сети мы
написали тулинг вокруг bwm-ng.

### A6

Недостаков не знаю вроде (привык уже). Нравится retry (в Java, C# такого нет)

### A7

Javascript, CoffeeScript, Objective-C, C/C++, C#, Java, Action Script

## Level 2

### A1

`1660 / 100 != 16.6` - потому что тут деление на цело. Чтобы условие 
выполнялось необходимо, чтобы один из операндов был вещественного типа.
(`1660/100.0 == 16.6`)
`24.0 * 0.1 != 2.4` - из-за стандарта представления чисел с плавующей точкой в 
разрядной стетке. Необходимо проверять равенство с учетом некой дельты:

    delta = 0.1 ** 6
    (24.0 * 0.1 - 2.4).abs <= delta
    
### A2

 1. Я бы выбрал BSON да еще бы пожал бы его через gzip
 2. Поддержка бинарных данных (без эскейпинга), что позволит эффективно
    передавать вложения. Хорошая поддержка формата на обоих сторонах 
    (ruby - bson_ext, action script - https://github.com/argoncloud/ActionBSON).
 
### A3
 
Потоки это механизм паралельного выполнения кода в одном процессе. При 
этом общая память доступна для чтения и записи. Форки - это 
механизм копирования процессов. При этом общая память доступна только для
чтения. В случае с руби (MRI) настоящего параленього выполнения в потоках
можно добиться только в IO или на native уровне.
Насчет инструментария, то мне только известны Java профайлеры и дебагеры.

### A4

На базе EventMachine, можно писать настоящий асинхронный код на ruby. 
Ruby 1.9 fibers позволяют скрыть множественные callbacks и делают год более 
простым.
    
### A5

[grab.rb](bin/grab.rb) и 
[grabber.rb](lib/grabber.rb)

спека [grabber_spec.rb](spec/grabber_spec.rb)
 
## Level 3

### A1

Достаю только картинки из тэгов IMG и скачиваю их в 10 потоков

[finder.rb](lib/finder.rb)

спека [finder_spec.rb](spec/finder_spec.rb)

### A2

Вообщем ruby медленный язык, так как интерпретируется каждый раз. Evan делает
rubinius с JIT-ом и убирает GIL. Как я понимаю, за rbx будущие, но сейчас он 
сильно отстает по производительности от 1.9 MRI.
Один из путей оптимизации кода - это переписывать на C узкие участки программы.
Если native code не брать в расчет, то я предерживаюсь следующий здравых правил:

 1. Не плодить объекты - GC медленный  в ruby
 2. Не делать callstack большим - тоже связанно с работой GC
 3. Не использовать eval
 
### A3

  1. Заранее построить индексы по полям [Возраст, Рост, Индекс, Сумма Денег]
  2. Начинать фильтровать записи с узких индексов [индекс, сумма денег]
     даллее [Возраст, Рост].
  3. Оставшиеся записи проврить фильтром [Пол] \(Если он есть\)
  